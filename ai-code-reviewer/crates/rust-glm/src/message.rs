use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use crate::{glm_client, jwt};

pub(crate) trait Message {
    fn new(content: String) -> Self;

    fn to_value(&self) -> Value
    where Self: Serialize {
        serde_json::to_value(self).unwrap()
    }
}

/// ChatGLM provide 4 types of Message
#[derive(Serialize, Deserialize)]
pub(crate) enum MessageType {
    /// preset chat scene
    System(SystemMessage),
    /// user query message
    User(UserMessage),
    /// AI model reply message
    Assistant(AssistantMessage),
    /// message generated by tools
    Tool(ToolMessage),
}

#[derive(Serialize, Deserialize)]
pub(crate) struct SystemMessage {
    role: String,
    content: String,
}

impl Message for SystemMessage {
    fn new(content: String) -> Self {
        Self {
            role: "system".to_string(),
            content,
        }
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct UserMessage {
    role: String,
    content: String,
}

impl Message for UserMessage {
    fn new(content: String) -> Self {
        Self {
            role: "user".to_string(),
            content,
        }
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct AssistantMessage {
    role: String,
    content: Option<String>,
    tool_calls: Option<Vec<ToolCall>>,
}

impl Message for AssistantMessage {
    fn new(content: String) -> Self {
        Self {
            role: "assistant".to_string(),
            content: Some(content),
            tool_calls: None,
        }
    }
}

#[derive(Serialize, Deserialize)]
struct ToolCall {
    id: String,
    _type: String,
    function: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub(crate) struct ToolMessage {
    role: String,
    content: String,
    tool_call_id: String,
}

impl Message for ToolMessage {
    fn new(content: String) -> Self {
        todo!()
    }
}

/// user query message
pub struct Query<'c> {
    config: &'c glm_client::Config,     //'c: just restrict Config object live longer enough than config
    /// transfer mode: Sse Sync Async
    trans_mode: TransferMode,
    /// message this query
    message: String,
    // GLM model
    // glm_model: &'m GlmModel,
    /// call ChatGLM API need jwt token
    jwt: String,
}

impl Query<'_> {
    /// construct query from chat message and client configuration
    pub fn from_string<'a>(input: &'a str, config: &'a glm_client::Config) -> Query<'a> {   //这里'a实际最终是选择更小的约束，注意只是约束，不是将Query对象的生命周期设置为'a
        let (mut trans_type, mut message) = (String::new(), String::new());

        // every query can choose different invoke methods: sse(default) async sync，for example sse#<user_input>
        let regex = Regex::new(r"([^#]+)#([^#]+)").unwrap();
        if let Some(captures_message) = regex.captures(input) {
            trans_type = captures_message.get(1).map_or_else(
                || String::new(), |m| m.as_str().to_string());
            message = captures_message.get(2).map_or_else(
                || String::new(), |m| m.as_str().to_string());
        } else {
            message = input.trim().to_string();
        }

        Query {
            config,
            trans_mode: TransferMode::from_string(&trans_type),
            message,
            // get or create jwt token
            // if not exist or about to expire create new one, otherwise reuse
            jwt: jwt::get_or_create(config.api_key()),
        }
    }

    pub(crate) fn config(&self) -> &glm_client::Config {
        self.config
    }

    pub(crate) fn trans_mode(&self) -> &TransferMode {
        &self.trans_mode
    }

    pub(crate) fn message(&self) -> &String {
        &self.message
    }

    pub(crate) fn jwt(&self) -> String {
        self.jwt.clone()
    }
}

/// ChatGLM reply message
struct Reply {}

pub(crate) enum TransferMode {
    /// stream
    Sse,
    Sync,
    Async,
}

impl TransferMode {
    fn from_string(mode: &str) -> TransferMode {
        match mode {
            "sse" => TransferMode::Sse,
            "sync" => TransferMode::Sync,
            "async" => TransferMode::Async,
            _ => TransferMode::Sse,
        }
    }

    pub(crate) fn is_stream(&self) -> bool {
        match self {
            TransferMode::Sse => true,
            _ => false,
        }
    }
}
