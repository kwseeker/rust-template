/*
å®
å®å±äºå…ƒç¼–ç¨‹ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µç”ŸæˆRustä»£ç ã€‚
ç°åœ¨å¾ˆå¤šè¯­è¨€éƒ½æä¾›äº†å®æ“ä½œï¼Œå¤§è‡´å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š æ–‡æœ¬æ›¿æ¢å’Œè¯­æ³•æ‰©å±•ã€‚
    Cè¯­è¨€ä¸­çš„å®å‡½æ•°å°±å±äºæ–‡æœ¬æ›¿æ¢ã€‚Rust å®å±äºè¯­æ³•æ‹“å±•ã€‚
å‚è€ƒï¼š
    ã€ŠRustç¼–ç¨‹ä¹‹é“ã€‹ï¼ˆå…¥é—¨ï¼‰
    ã€ŠRustå®å°å†Œã€‹ï¼ˆæ·±å…¥ï¼ŒåŒ…å«å®Œæ•´çš„è¯­æ³•è®²è§£å’Œä¸°å¯Œçš„å®ä¾‹ï¼‰ï¼šhttps://zjp-cn.github.io/tlborm/#/
å®çš„åˆ†ç±»ï¼š
    å£°æ˜å®ï¼šä½¿ç”¨macro_ruleså£°æ˜
        å£°æ˜å®çš„å®šä¹‰æ ¼å¼ï¼š
            macro_rules! $name {
                $rule0 ;
                $rule1 ;
                // â€¦
                $ruleN ;
            }
            æ¯æ¡è§„åˆ™çš„æ ¼å¼ï¼š
                 ($matcher) => {$expansion}
                matcher è¿˜å¯ä»¥åŒ…å«æ•è· (captures)ã€‚å³åŸºäºæŸç§é€šç”¨è¯­æ³•ç±»åˆ«æ¥åŒ¹é…è¾“å…¥ï¼Œå¹¶å°†ç»“æœæ•è·åˆ°å…ƒå˜é‡ (metavariable) ä¸­ï¼Œç„¶åå°†æ›¿æ¢å…ƒå˜é‡åˆ°è¾“å‡ºã€‚
                æ•è·çš„ä¹¦å†™æ–¹å¼æ˜¯ï¼šå…ˆå†™ç¾å…ƒç¬¦å· $ï¼Œç„¶åè·Ÿä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œç„¶åæ˜¯å†’å· :ï¼Œæœ€åæ˜¯æ•è·æ–¹å¼ï¼Œæ¯”å¦‚ $e:exprã€‚
                æ•è·æ–¹å¼åˆè¢«ç§°ä½œâ€œç‰‡æ®µåˆ†ç±»ç¬¦â€ (fragment-specifier)ï¼Œå¿…é¡»æ˜¯ä»¥ä¸‹ä¸€ç§ï¼š
                    blockï¼šä¸€ä¸ªå—ï¼ˆæ¯”å¦‚ä¸€å—è¯­å¥æˆ–è€…ç”±å¤§æ‹¬å·åŒ…å›´çš„ä¸€ä¸ªè¡¨è¾¾å¼ï¼‰
                    exprï¼šä¸€ä¸ªè¡¨è¾¾å¼ (expression)
                    identï¼šä¸€ä¸ªæ ‡è¯†ç¬¦ (identifier)ï¼ŒåŒ…æ‹¬å…³é”®å­— (keywords)
                    itemï¼šä¸€ä¸ªæ¡ç›®ï¼ˆæ¯”å¦‚å‡½æ•°ã€ç»“æ„ä½“ã€æ¨¡å—ã€impl å—ï¼‰
                    lifetimeï¼šä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼ˆæ¯”å¦‚ 'fooã€'staticï¼‰
                    literalï¼šä¸€ä¸ªå­—é¢å€¼ï¼ˆæ¯”å¦‚ "Hello World!"ã€3.14ã€'ğŸ¦€'ï¼‰
                    metaï¼šä¸€ä¸ªå…ƒä¿¡æ¯ï¼ˆæ¯”å¦‚ #[...] å’Œ #![...] å±æ€§å†…éƒ¨çš„ä¸œè¥¿ï¼‰
                    patï¼šä¸€ä¸ªæ¨¡å¼ (pattern)
                    pathï¼šä¸€æ¡è·¯å¾„ï¼ˆæ¯”å¦‚ fooã€::std::mem::replaceã€transmute::<_, int>ï¼‰
                    stmtï¼šä¸€æ¡è¯­å¥ (statement)
                    ttï¼šå•æ£µæ ‡è®°æ ‘
                    tyï¼šä¸€ä¸ªç±»å‹
                    visï¼šä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å¯è§†æ ‡è¯†ç¬¦ï¼ˆæ¯”å¦‚ pubã€pub(in crate)ï¼‰
    è¿‡ç¨‹å®ï¼š
        å‡½æ•°å¼ï¼šå®ç° $nameï¼$input åŠŸèƒ½çš„å®
        å±æ€§å¼ï¼šå®ç° #[$input] åŠŸèƒ½çš„å±æ€§
        derive å¼ï¼šå®ç° #[derive($name)] åŠŸèƒ½çš„å±æ€§
å®æŒ‰ä½¿ç”¨è¯­æ³•å½¢å¼åˆ†ç±»ï¼š
    è°ƒç”¨å®ï¼š
    å±æ€§å®ï¼š
å®å±•å¼€è¿‡ç¨‹ï¼š
å®å’Œå‡½æ•°çš„åŒºåˆ«ï¼š
    å®å¯ä»¥æ¥æ”¶ä¸é€šæ•°é‡çš„å‚æ•°ï¼›å®å¯ä»¥åœ¨ç¼–è¯‘å™¨ç¿»è¯‘ä»£ç å‰å±•å¼€ï¼ˆæ¯”å¦‚å®å¯ä»¥åœ¨ä¸€ä¸ªç»™å®šç±»å‹ä¸Šå®ç°Traitï¼‰ï¼›
    å®å®šä¹‰æ¯”å‡½æ•°å®šä¹‰æ›´å¤æ‚ï¼Œä¹Ÿæ›´éš¾ä»¥é˜…è¯»ã€ç†è§£å’Œç»´æŠ¤ï¼›
    åœ¨ä¸€ä¸ªæ–‡ä»¶ï§©è°ƒç”¨å® ä¹‹å‰ å¿…é¡»å®šä¹‰å®ƒï¼Œæˆ–å°†å…¶å¼•å…¥ä½œç”¨åŸŸï¼Œè€Œå‡½æ•°åˆ™å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹å®šä¹‰å’Œè°ƒç”¨ã€‚

*/

//æœ€ç®€å•çš„å£°æ˜å®å®šä¹‰ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°å£°æ˜å®æœ€åŸºç¡€çš„ç»“æ„
#[macro_export]
macro_rules! one {
    () => {1}
}

#[macro_export]
macro_rules! num {
    ( $($num:literal),* ) => {

    };
}

///è¿™é‡Œåˆ†æ”¯æ¨¡å¼çš„è§£é‡Šï¼š( $( $x:expr ),* )
/// ç¾å…ƒç¬¦å·ï¼ˆ$ ï¼‰åœ¨å®ç³»ç»Ÿä¸­å£°æ˜ä¸€ä¸ªå˜ï¥¾æ¥åŒ…å«åŒ¹é…è¯¥æ¨¡å¼çš„ Rust ä»£ç ã€‚ç¾å…ƒç¬¦å·æ˜ç¡®è¡¨æ˜è¿™æ˜¯ä¸€ä¸ªå®å˜ï¥¾è€Œï¥§æ˜¯æ™®é€š Rust å˜ï¥¾ã€‚
/// ä¹‹åæ˜¯ä¸€å¯¹æ‹¬å·ï¼Œå…¶æ•è·äº†ç¬¦åˆæ‹¬å·å†…æ¨¡å¼çš„å€¼ç”¨ä»¥åœ¨æ›¿ä»£ä»£ç ä¸­ä½¿ç”¨ã€‚$() å†…åˆ™æ˜¯ $x:expr ï¼Œå…¶åŒ¹é…Rust çš„ä»»æ„è¡¨è¾¾å¼ï¼Œå¹¶å°†è¯¥è¡¨è¾¾å¼å‘½åä¸º $x ã€‚
/// $() ä¹‹åçš„é€—å·è¯´æ˜ä¸€ä¸ªå¯æœ‰å¯æ— çš„é€—å·åˆ†éš”ç¬¦å¯ä»¥å‡ºç°åœ¨ $() æ‰€åŒ¹é…çš„ä»£ç ä¹‹åã€‚ç´§éšé€—å·ä¹‹åçš„ * è¯´æ˜è¯¥æ¨¡å¼åŒ¹é…é›¶ä¸ªæˆ–ï¤å¤šä¸ª * ä¹‹å‰çš„ä»»ä½•æ¨¡å¼ã€‚
#[macro_export]
macro_rules! my_vec {
    //è¿™é‡Œ x æ˜¯è‡ªå®šä¹‰å‘½å, expr æ˜¯ä¸€ä¸ªç‰‡æ®µåˆ†ç±»ç¬¦ï¼š fragment specifierï¼Œ
    // valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, `literal`, `path`, `meta`, `tt`, `item` and `vis`
    // ( $( $x:expr ),* ) => {
    ( $( $var:expr ),* ) => { //
        {
            let mut temp_vec = Vec::new();
            $(
                // temp_vec.push($x);
                temp_vec.push($var);
            )*
            temp_vec
        }
    };
}

#[macro_export]
macro_rules! string {
    ($e:expr) => {String::from($e)};
}

#[test]
fn test_marco() {
    let one = one!();
    println!("one: {one}");
    let v = my_vec![1, 3, 5];
    println!("v: {v:?}");
    let s = string!("hello");
    println!("s: {s}");
}

